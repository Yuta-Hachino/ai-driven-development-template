name: Autonomous Auto-Fix

on:
  workflow_dispatch:
    inputs:
      failure_type:
        description: 'Type of failure to fix'
        required: true
        type: string
      commit:
        description: 'Commit SHA that failed'
        required: true
        type: string
      workflow_url:
        description: 'URL of failed workflow'
        required: false
        type: string

  issue_comment:
    types: [created]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  check-command:
    name: Check for Auto-Fix Command
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment'
    outputs:
      should_fix: ${{ steps.check.outputs.should_fix }}
      issue_number: ${{ steps.check.outputs.issue_number }}

    steps:
      - name: Check comment for /auto-fix command
        id: check
        uses: actions/github-script@v6
        with:
          script: |
            const comment = context.payload.comment.body;
            const shouldFix = comment.trim().startsWith('/auto-fix');

            core.setOutput('should_fix', shouldFix);
            core.setOutput('issue_number', context.issue.number);

            if (shouldFix) {
              await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: 'rocket'
              });
            }

            return shouldFix;

  auto-fix:
    name: Attempt Automatic Fix
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issue_comment' && needs.check-command.outputs.should_fix == 'true')
    needs: [check-command]

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.inputs.commit || github.sha }}
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          pip install black isort autoflake

      - name: Analyze failure type
        id: analyze
        run: |
          FAILURE_TYPE="${{ github.event.inputs.failure_type || 'test' }}"
          echo "failure_type=$FAILURE_TYPE" >> $GITHUB_OUTPUT

          case "$FAILURE_TYPE" in
            test)
              echo "fix_strategy=run_tests_and_fix" >> $GITHUB_OUTPUT
              ;;
            code-quality)
              echo "fix_strategy=auto_format" >> $GITHUB_OUTPUT
              ;;
            security)
              echo "fix_strategy=manual_required" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "fix_strategy=generic_fix" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Auto-format code (Code Quality)
        if: steps.analyze.outputs.fix_strategy == 'auto_format'
        run: |
          echo "üîß Auto-formatting code..."

          # Remove unused imports
          autoflake --in-place --remove-all-unused-imports --recursive src/ tests/ || true

          # Sort imports
          isort src/ tests/ || true

          # Format with black
          black src/ tests/ || true

          echo "‚úÖ Code formatting complete"

      - name: Run tests and collect errors (Test Failures)
        if: steps.analyze.outputs.fix_strategy == 'run_tests_and_fix'
        id: test
        continue-on-error: true
        run: |
          echo "üß™ Running tests to identify failures..."

          # Run tests and capture output
          pytest tests/ -v --tb=short > test_output.txt 2>&1 || true

          # Extract failed test names
          grep "FAILED" test_output.txt | awk '{print $1}' > failed_tests.txt || true

          FAILED_COUNT=$(wc -l < failed_tests.txt || echo "0")
          echo "failed_count=$FAILED_COUNT" >> $GITHUB_OUTPUT

          if [ "$FAILED_COUNT" -gt 0 ]; then
            echo "‚ùå Found $FAILED_COUNT failed tests"
            cat failed_tests.txt
          else
            echo "‚úÖ All tests passing"
          fi

      - name: Attempt test fixes
        if: steps.analyze.outputs.fix_strategy == 'run_tests_and_fix' && steps.test.outputs.failed_count != '0'
        run: |
          echo "üîß Attempting to fix test failures..."

          # Common test fixes
          # 1. Fix import issues
          find src/ tests/ -name "*.py" -exec sed -i 's/from \.\./from src\./g' {} \; || true

          # 2. Fix async test markers
          find tests/ -name "test_*.py" -exec sed -i '/@pytest.mark.asyncio/! s/^async def test_/@pytest.mark.asyncio\nasync def test_/g' {} \; || true

          # 3. Re-run tests
          pytest tests/ -v --tb=short || true

          echo "‚úÖ Fix attempts complete"

      - name: Security check (Manual Required)
        if: steps.analyze.outputs.fix_strategy == 'manual_required'
        run: |
          echo "‚ö†Ô∏è Security issues require manual review"
          echo "Automatic fixes are not applied for security vulnerabilities"
          exit 1

      - name: Verify fixes
        id: verify
        run: |
          echo "üîç Verifying fixes..."

          # Check if there are any changes
          if git diff --quiet; then
            echo "No changes made"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "verification=no_changes_needed" >> $GITHUB_OUTPUT
          else
            echo "Changes detected"
            echo "has_changes=true" >> $GITHUB_OUTPUT

            # Run full CI checks
            if pytest tests/ -v && black --check src/ tests/; then
              echo "verification=success" >> $GITHUB_OUTPUT
              echo "‚úÖ Fixes verified successfully"
            else
              echo "verification=partial" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è Fixes applied but issues remain"
            fi
          fi

      - name: Create auto-fix branch
        if: steps.verify.outputs.has_changes == 'true'
        id: create_branch
        run: |
          BRANCH_NAME="auto-fix/$(date +%Y%m%d-%H%M%S)-${{ steps.analyze.outputs.failure_type }}"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

          git config user.name "Autonomous Dev Bot"
          git config user.email "bot@autonomous-dev.io"

          git checkout -b "$BRANCH_NAME"
          git add .
          git commit -m "fix: Auto-fix for ${{ steps.analyze.outputs.failure_type }} failures

Automated fixes applied by autonomous development system:
- Failure type: ${{ steps.analyze.outputs.failure_type }}
- Strategy: ${{ steps.analyze.outputs.fix_strategy }}
- Verification: ${{ steps.verify.outputs.verification }}

Original commit: ${{ github.event.inputs.commit }}

ü§ñ This commit was automatically generated"

          git push origin "$BRANCH_NAME"

          echo "‚úÖ Pushed fixes to branch: $BRANCH_NAME"

      - name: Create Pull Request
        if: steps.verify.outputs.has_changes == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            const branchName = '${{ steps.create_branch.outputs.branch_name }}';
            const failureType = '${{ steps.analyze.outputs.failure_type }}';
            const verification = '${{ steps.verify.outputs.verification }}';

            const title = `ü§ñ Auto-fix: ${failureType} failures`;

            const body = `## Automated Fix

This PR contains automated fixes for **${failureType}** failures.

### Fix Details

- **Failure Type**: ${failureType}
- **Fix Strategy**: ${{ steps.analyze.outputs.fix_strategy }}
- **Verification Status**: ${verification}
- **Original Commit**: \`${{ github.event.inputs.commit }}\`

### Changes Applied

${ verification === 'success' ? '‚úÖ All fixes verified successfully' : '‚ö†Ô∏è Partial fixes - manual review recommended' }

### Testing

- [ ] Automated tests pass
- [ ] Code quality checks pass
- [ ] Security scans pass
- [ ] Manual verification (if needed)

### Merge Strategy

${ verification === 'success'
  ? '‚úÖ **Ready to merge** - All automated checks passed'
  : '‚ö†Ô∏è **Review required** - Some issues may remain' }

---

ü§ñ *This PR was automatically created by the autonomous development system*

**Auto-merge**: ${ verification === 'success' ? 'Enabled after CI passes' : 'Disabled - manual review required' }
`;

            const pr = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              head: branchName,
              base: context.ref.replace('refs/heads/', ''),
              draft: verification !== 'success'
            });

            // Add labels
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.data.number,
              labels: ['automated', 'auto-fix', failureType]
            });

            console.log(`Created PR #${pr.data.number}`);

            // Comment on original issue if exists
            if (context.payload.issue) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: `ü§ñ Auto-fix PR created: #${pr.data.number}\n\nVerification status: **${verification}**`
              });
            }

      - name: Update issue status
        if: always() && github.event_name == 'issue_comment'
        uses: actions/github-script@v6
        with:
          script: |
            const hasChanges = '${{ steps.verify.outputs.has_changes }}';
            const verification = '${{ steps.verify.outputs.verification }}';

            let message = '### Auto-Fix Result\n\n';

            if (hasChanges === 'false') {
              message += '‚úÖ No fixes needed - tests already passing';
            } else if (verification === 'success') {
              message += '‚úÖ Fixes applied successfully and verified';
            } else if (verification === 'partial') {
              message += '‚ö†Ô∏è Partial fixes applied - manual review needed';
            } else {
              message += '‚ùå Unable to apply automatic fixes';
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ needs.check-command.outputs.issue_number }},
              body: message
            });
